# MIT License

# Copyright (c) 2021 YL Feng <fengyulong@pku.org.cn>

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


"""
Abstract: about app
    usefull functions for users to interact with `QuarkServer` and database
"""

import subprocess
import sys
import time
from collections import defaultdict
from functools import wraps
from importlib import import_module
from pathlib import Path
from threading import current_thread
from typing import Callable

import numpy as np
from loguru import logger
from srpc import connect, loads
from zee import flatten_dict

from . import _dp as dp
from ._db import get_tid_by_rid
from ._recipe import Recipe
from ._task import Task


class Super(object):
    """Super Admin Tool to interact with `QuarkServer` and database and so on"""

    def __init__(self):
        pass

    def init(self, path: str | Path = Path.cwd() / 'quark.json'):
        """Set path to `quark.json`

        Args:
            path (str | Path, optional): path to quark.json. Defaults to `Path.cwd()/'quark.json'`.
        """
        from quark.proxy import init
        init(path)

    def recipe(self, name: str = '', **kwds) -> Recipe:
        """Create a recipe

        Args:
            name (str, optional): name of the recipe. Defaults to ''.

        Returns:
            Recipe: a recipe object
        """
        return Recipe(name, **kwds)

    def __repr__(self):
        try:
            return f'connection to {self.addr}'
        except Exception as e:
            return ''

    def qs(self):
        try:
            return self._s
        except Exception as e:
            raise AttributeError('Please login first!')

    @property
    def addr(self):
        try:
            return self.qs().raddr
        except Exception as e:
            return ('127.0.0.1', str(e))

    def user_exists(self):
        return self.qs().user_exists

    def login(self, user: str = 'baqis', host: str = '127.0.0.1', port: int = 2088):
        """Login to the QuarkServer

        Args:
            user (str, optional): name of the user(same as signup). Defaults to 'baqis'.
            host (str, optional): server host. Defaults to '127.0.0.1'.
            port (str, optional): server port. Defaults to 2088.
        """

        self._s = login(user, host, port)

        for mth in ['start', 'query', 'write', 'read', 'checkpoint', 'track', 'getid', 'cancel', 'report', 'review', 'tail']:
            setattr(self, mth, getattr(self._s, mth))

        # for name in ['signup', 'submit']:
        #     setattr(self, name, globals()[name])

    def signup(self, user: str, system: str, **kwds):
        """Register a new **user** on the **system**

        Args:
            user (str): name of the user
            system (str): name of the system(i.e. the name of the cfg file)
        """
        signup(user, system, **kwds)

    def submit(self, task: dict, block: bool = False, **kwds):
        """Submit a task to a backend

        Args:
            task (dict): description of a task generated by `Recipe`.
            block (bool, optional): block until the task is done if True

        Keyword Arguments: Kwds
            preview (list): real time display of the waveform
            plot (bool): plot the result if True(1D or 2D), defaults to False.
            backend (connection): connection to a backend, defaults to local machine.
        Raises:
            TypeError: _description_
        """
        return submit(task, block, **kwds)

    def ping(self):
        return ping(self.qs())

    def snapshot(self, tid: int = 0):
        """Get snapshot of a task with given id(**tid** or **rid**). 
        If tid is 0, current snapshot will be retrieved from `QuarkServer`.

        Args:
            tid (int, optional): task id. Defaults to 0.

        Returns:
            dict: _description_
        """
        if tid and self.addr[0] == '127.0.0.1':
            if tid < 1e10:
                return get_config_by_rid(tid)
            return get_config_by_tid(tid)
        else:
            return self.qs().snapshot(tid=tid)

    def rollback(self, tid: int):
        """Rollback the cfg with given id(**tid** or **rid**)

        Args:
            tid (int): task id
        """
        if tid:
            rollback(tid)
        else:
            raise ValueError('rid or tid is required!')

    def result(self, tid: int, **kwds):
        """Get data with given id(**tid** or **rid**)

        Args:
            tid (int): task id

        Keyword Arguments: Kwds
            plot (bool, optional): plot the result in QuarkStudio after the data is loaded(1D or 2D).

        Returns:
            dict: data & meta
        """
        if self.addr[0] == '127.0.0.1':
            if tid < 1e10:
                return get_data_by_rid(tid, **kwds)
            return get_data_by_tid(tid, **kwds)
        else:
            data = self.qs().load(tid)
            try:
                from ._db import reshape

                shape = data['meta']['other']['shape']
                data['data'] = {k: reshape(np.asarray(v), shape)
                                for k, v in data['data'].items()}
            except Exception as e:
                logger.error(f'Failed to reshape data: {e}')
            return data

    def lookup(self, start: str = '', end: str = '', name: str = ''):
        """Lookup records in the database

        Args:
            start (str, optional): start date. Defaults to ''.
            end (str, optional): end date. Defaults to ''.
            name (str, optional): task name. Defaults to ''.

        Returns:
            _type_: _description_
        """
        if self.addr[0] == '127.0.0.1':
            return lookup(start, end, name)
        else:
            return lookup(records=self.qs().load(0))

    def update(self, path: str, value, failed: list = []):
        """Update item in the cfg

        Args:
            path (str): dot-separated keys like 'usr.station.name'
            value (_type_): value to update
            failed (list, optional): _description_. Defaults to [].
        """
        qs = self.qs()
        rs: str = qs.update(path, value)
        if rs.startswith('Failed'):
            if path.count('.') == 0:
                qs.create(path, value)
            else:
                path, _f = path.rsplit('.', 1)
                failed.append((_f, value))
                self.update(path, {}, failed)

        while failed:
            _f, v = failed.pop()
            path = f'{path}.{_f}'
            qs.update(path, v)

    def delete(self, path: str):
        """Delete an item from the cfg

        Args:
            path (str): dot-separated keys like 'usr.station.name'
        """
        qs = self.qs()
        if path.count('.') > 0:
            qs.delete(path)
        else:
            qs.remove(path)

    def profile(self):
        return self.qs().progress(profile=True)

    def translate(self, circuit: list = [(('Measure', 0), 'Q0')], cfg: dict = {}, tid: int = 0, **kwds) -> tuple:
        """Translate circuit to executable commands(i.e., waveforms or settings)

        Args:
            circuit (list, optional): qlisp circuit. Defaults to [(('Measure', 0), 'Q0')].
            cfg (dict, optional): parameters of qubits in the circuit. Defaults to {}.
            tid (int, optional): task id used to load cfg. Defaults to 0.

        Returns:
            tuple: context that contains cfg, translated result

        Example:
            ``` {.py3 linenums="1"}
            circuit = [('X', 'Q0'), (('Measure', 0), 'Q0')]
            cfg = s.snapshot()  # get current cfg from QuarkServer
            ctx, (cmds, dmap) = s.translate(circuit, cfg=cfg)
            ```
        """
        if not cfg:
            # for more details, see https://quarkstudio.readthedocs.io/en/latest/usage/code/cfg2/
            cfg = {
                'Q0': {
                    'Measure': {
                        'duration': 4e-06,
                        'amp': 0.019,
                        'frequency': 6964370000.0,
                        'weight': 'square(2e-6)>>2e-6',
                        'phi': -2.636421695283167,
                        'threshold': 8502633802.265065,
                        'ring_up_amp': 0.024,
                        'ring_up_waist': 0.006,
                        'ring_up_time': 6e-07
                    },
                    'acquire': {'address': 'AD.CH13.IQ', 'TRIGD': 0, 'srate': 2e9},
                    'probe': {'address': 'AWG.CH2.Waveform', 'delay': 0, 'srate': 6e9}
                },
                'station': {
                    'triggercmds': ['Trigger.CH1.TRIG'],
                    'lib': 'glib.gates.u3rcp',
                    'arch': 'rcp',
                    'align_right': False,
                    'waveform_length': 1.8e-05
                }
            }
        return translate(circuit, cfg, tid, **kwds)

    def preview(self, cmds: dict, keys: tuple[str] = ('',), calibrate: bool = True,
                start: float = 0, end: float = 0, srate: float = 0,
                unit: float = 1e-6, offset: float = 0, space: float = 0, ax=None):
        """Preview waveforms from commands

        Args:
            cmds (dict): command list generated by the compiler.
            keys (tuple[str], optional): keywords of waveforms to to preview. Defaults to ('',).
            calibrate (bool, optional): calculate distortion if True. Defaults to True.
            start (float, optional): start time. Defaults to 0.
            end (float, optional): end time. Defaults to 0.
            srate (float, optional): sampling rate. Defaults to 0.
            unit (float, optional): unit of time. Defaults to 1e-6.
            offset (float, optional): vertical offset between curves. Defaults to 0.
            space (float, optional): spacing between the curve and the y-axis. Defaults to 0.
            ax (Axes, optional): the Axes object (ax) in Matplotlib. Defaults to None.

        Returns:
            dict: Sampled waveform data

        Example:
            ``` {.py3 linenums="1"}
            # cmds is generated by s.translate
            wf = s.preview(cmds, keys=['Q0'], end=100e-6)
            ```
        """
        return preview(cmds, keys, calibrate, start, end, srate, unit, offset, space, ax)

    def run(self, cmds: dict, dev: dict = {
        'AD': {
            "addr": "192.168.1.2",
            "name": "dev.VirtualDevice",
            "type": "driver"
        },
        'AWG': {
            "host": "192.168.1.3",
            "port": 40001,
            "type": "remote"
        },
        'Trigger': {
            "addr": "192.168.1.4",
            "name": "dev.VirtualDevice",
            "type": "driver"
        }
    }, verbose: bool = True):
        """Execute experiment instruction sequence.

        Args:
            cmds (dict): Command dictionary from `task.step` or `s.translate`.
            dev (dict): Device dictionary.
            verbose (bool): Whether to print execution information. Defaults to True.

        Returns:
            dict: Dictionary containing read results.

        Raises:
            KeyError: When the target device is not in the device list.
        """
        dhs = {}
        for alias, info in dev.items():
            if info['type'] == 'driver':
                driver = import_module(info['name']).Driver(**info)
                driver.open()
            elif info['type'] == 'remote':
                driver = connect(alias,
                                 host=info['host'],
                                 port=info['port'],
                                 timeout=3.0
                                 )
            else:
                raise ValueError('unsupported type of device')
            dhs[alias] = driver
            logger.info(f'{alias}: {driver.info()}')

        result = {}
        for step, ops in cmds.items():
            for target, params in ops.items():
                d, ch, q = target.split('.')
                try:
                    ch = int(ch[2:])
                except ValueError as e:
                    ch = ch[2:]
                if d in dhs:
                    if verbose:
                        print(f"Execute: {step}->{target}: {params['value']}")

                    if step.lower() == 'read':
                        result[target] = dhs[d].getValue(q, ch=ch)
                    else:
                        dhs[d].setValue(q, params['value'], ch=ch)
                else:
                    logger.error(f"Device {d}({target}) not in device list")
        return result

    def diff(self, new: int | dict, old: int | dict, fmt: str = 'dict', ignore: list[str] = ['unit', 'sid']):
        """Compare two snapshots or records

        Args:
            new (int | dict): new snapshot or record id or dict
            old (int | dict): old snapshot or record id or dict
            fmt (str, optional): format of the output. Defaults to 'dict'.
            ignore (list[str], optional): keys to be ignored. Defaults to ['unit', 'sid'].

        Returns:
            _type_: _description_
        """
        return diff(new, old, fmt, ignore)

    def fig(self):
        from ._viewer import fig
        return fig

    def ssh(self, username: str, password: str, host: str = '192.168.1.42'):
        from quark.terminal import open_ssh
        return open_ssh(username, password, host)

    def terminal(self, command: str | None = None, cwd: str | None = None):
        from quark.terminal import open_terminal
        open_terminal(command, cwd)

    def display(self, d: dict | np.ndarray = {}, filename: str = '', title="root", **kwds):
        """Print nested dict as a tree

        Args:
            d (dict): dict to be printed as tree.
            filename (str, optional): hdf5 or zarr file. Defaults to ''.
            title (str, optional): root name. Defaults to "root".

        Returns:
            _type_: _description_
        """

        if filename and filename.endswith(('hdf5', 'zarr')):
            from ._db import get_tree_of_file
            d = get_tree_of_file(filename)
            if not d:
                return
            title = 'hdf5'

        from quark.terminal import display
        kwds.setdefault('end', '')
        display(d, title, **kwds)


_sp = {}  # defaultdict(lambda: connect('QuarkServer', host, port))

s = Super()


def ping(qs):
    return qs.ping('hello') == 'hello'


def login(user: str = 'baqis', host: str = '127.0.0.1', port: int = 2088, verbose: bool = True):
    # """login to the server as **user**

    # Args:
    #     user (str, optional): name of the user(same as signup). Defaults to 'baqis'.
    #     verbose (bool, optional): print login info if True. Defaults to True.

    # Returns:
    #     _type_: a connection to the server
    # """
    uid = f'{current_thread().name}: {user}@{host}:{port}'
    try:
        qs = _sp[uid]
    except KeyError as e:
        qs = _sp[uid] = connect('QuarkServer', host, port)

    m: str = qs.login(user)
    qs.user_exists = isinstance(m, str) and not m.startswith('LookupError')
    if verbose:
        logger.info(m)
    return qs


def signup(user: str, system: str, **kwds):
    # """register a new **user** on the **system**

    # Args:
    #     user (str): name of the user
    #     system (str): name of the system(i.e. the name of the cfg file)
    # """
    qs = s.qs()
    logger.info(qs.adduser(user, system, **kwds))
    qs.login(user)  # relogin


def submit(task: dict, block: bool = False, **kwds):
    # """submit a task to a backend

    # Args:
    #     task (dict): description of a task
    #     block (bool, optional): block until the task is done if True

    # Keyword Arguments: Kwds
    #     preview (list): real time display of the waveform
    #     plot (bool): plot the result if True(1D or 2D), defaults to False.
    #     backend (connection): connection to a backend, defaults to local machine.

    # Raises:
    #     TypeError: _description_

    # Example: description of a task
    #     ``` {.py3 linenums="1"}
    #     {
    #         'meta': {'name': f'{filename}: /s21',  # s21 is the name of the dataset
    #                  # extra arguments for compiler and others
    #                  'other': {'shots': 1234, 'signal': 'iq', 'autorun': False}},
    #         'body': {'step': {'main': ['WRITE', ('freq', 'offset', 'power')],  # main is reserved
    #                           'step2': ['WRITE', 'trig'],
    #                           'step3': ['WAIT', 0.8101],  # wait for some time in the unit of second
    #                           'READ': ['READ', 'read'],
    #                           'step5': ['WAIT', 0.202]},
    #                  'init': [('Trigger.CHAB.TRIG', 0, 'any')],  # initialization of the task
    #                  'post': [('Trigger.CHAB.TRIG', 0, 'any')],  # reset of the task
    #                  'cirq': ['cc'],  # list of circuits in the type of qlisp
    #                  'rule': ['‚ü®gate.Measure.Q1.params.frequency‚ü© = ‚ü®Q0.setting.LO‚ü©+‚ü®Q2.setting.LO‚ü©+1250'],
    #                  'loop': {'freq': [('Q0.setting.LO', np.linspace(0, 10, 2), 'Hz'),
    #                                    ('gate.Measure.Q1.index',  np.linspace(0, 1, 2), 'Hz')],
    #                           'offset': [('M0.setting.TRIGD', np.linspace(0, 10, 1), 'Hz'),
    #                                      ('Q2.setting.LO', np.linspace(0, 10, 1), 'Hz')],
    #                           'power': [('Q3.setting.LO', np.linspace(0, 10, 15), 'Hz'),
    #                                     ('Q4.setting.POW', np.linspace(0, 10, 15), 'Hz')],
    #                           'trig': [('Trigger.CHAB.TRIG', 0, 'any')],
    #                           'read': ['NA10.CH1.TraceIQ', 'M0.setting.POW']
    #                         }
    #                 },
    #     }
    #     ```

    # Todo: fixes
    #     * `bugs`
    # """

    if 'backend' in kwds:  # from master
        qs = kwds['backend']
    else:
        qs = s.qs()

        # trigger: list[str] = qs.query('station.triggercmds')
        # station = s.query('station')
        # task['body']['loop']['trig'] = [(t, 0, 'au')
        #                                 for t in station.get('triggercmds', [])]
        # task['meta']['other'].update(station)

        # waveforms to be previewed
        qs.update('etc.canvas.filter', kwds.get('preview', []))

    t = Task(task,
             timeout=1e9 if block else None,
             plot=kwds.get('plot', False))
    t.server = qs
    t.run()
    return t


def rollback(tid: int):
    # """rollback the parameters with given task id and checkpoint name

    # Args:
    #     tid (int): task id
    # """
    qs = s.qs()

    try:
        if tid < 1e10:  # rid
            config = get_config_by_rid(tid)
        else:
            config = get_config_by_tid(tid)
        qs.clear()
        for k, v in config.items():
            qs.create(k, v)
    except Exception as e:
        logger.error(f'Failed to rollback for {tid}: {e}')


def diff(new: int | dict, old: int | dict, fmt: str = 'dict', ignore: list[str] = ['unit', 'sid']):

    if fmt == 'dict':
        fda = flatten_dict(get_config_by_rid(
            new) if isinstance(new, int) else new)
        fdb = flatten_dict(get_config_by_rid(
            old) if isinstance(old, int) else old)
        changes = {}
        for k in set(fda) | set(fdb):
            if any(s in k for s in ignore):
                continue

            if k in fda and k in fdb:
                try:
                    if isinstance(fda[k], np.ndarray) and isinstance(fdb[k], np.ndarray):
                        if not np.all(fda[k] == fdb[k]):
                            changes[k] = f'{fdb[k]}\r\n->{" ":<{len(k)}}{fda[k]}'
                    elif fda[k] != fdb[k]:
                        changes[k] = f'{fdb[k]}\r\n->{" ":<{len(k)}}{fda[k]}'
                except Exception as e:
                    print(e)
                    changes[k] = f'{fdb[k]}\r\n->{" ":<{len(k)}}{fda[k]}'
            elif k in fda and k not in fdb:
                changes[k] = f'üÜï\r\n->{" ":<{len(k)}}{fda[k]}'
            elif k not in fda and k in fdb:
                changes[k] = f'{fdb[k]}\r\n->{" ":<{len(k)}}üóëÔ∏è'

        return changes
    elif fmt == 'git':
        from ._db import get_commit_by_tid
        assert isinstance(new, int), 'argument must be an integer'
        assert isinstance(old, int), 'argument must be an integer'

        cma, fa = get_commit_by_tid(get_tid_by_rid(new))
        cmb, fb = get_commit_by_tid(get_tid_by_rid(old))
        msg = ''
        for df in cma.diff(cmb, create_patch=True):
            # msg = str([0])
            if fa.name == df.a_path and fb.name == df.b_path:
                msg = df.diff.decode('utf-8')

        return msg


def lookup(start: str = '', end: str = '', name: str = '', fmt: str = '%Y-%m-%d-%H-%M-%S', records: list = []):
    import itables
    import pandas as pd

    from ._db import get_record_list_by_name
    from ._viewer import PagedTable

    itables.init_notebook_mode()
    itables.options.style = "width:100%"  # ËÆ©Ë°®Ê†ºÂÆΩÂ∫¶‰∏∫100%

    if not records:
        days = time.localtime(time.time() - 14 * 24 * 60 * 60)
        start = time.strftime(fmt, days) if not start else start
        end = time.strftime(fmt) if not end else end
        rs = get_record_list_by_name(name, start, end)[::-1]
    else:
        rs = records

    try:
        df = pd.DataFrame(rs)[[0, 1, 2, 6, 9, 10]]
        df.columns = ['rid', 'tid', 'name', 'status', 'created', 'finished']
    except Exception as e:
        # logger.error(f'Failed to get records: {e}')
        return pd.DataFrame()

    # paged_table = PagedTable(df, page_size=10)
    # paged_table.show()
    return df

    # -------------------------------------------------------------------------
    # items_per_page = 10
    # total_pages = (len(df) + items_per_page - 1) // items_per_page
    # setting = {'current': 1}

    # output = widgets.Output()
    # prev_button = widgets.Button(description="Previous")
    # next_button = widgets.Button(description="Next")
    # page_label = widgets.Label(value=f"Page 1 of {total_pages}")

    # def display_table(page):
    #     setting['current'] = page
    #     current_page = setting['current']

    #     start_idx = (current_page - 1) * items_per_page
    #     end_idx = start_idx + items_per_page

    #     with output:
    #         output.clear_output()
    #         display(df.iloc[start_idx:end_idx])

    #     page_label.value = f"Page {current_page} of {total_pages}"

    # def on_prev_clicked(b):
    #     current_page = setting['current']
    #     if current_page > 1:
    #         display_table(current_page - 1)

    # def on_next_clicked(b):
    #     current_page = setting['current']
    #     if current_page < total_pages:
    #         display_table(current_page + 1)

    # prev_button.on_click(on_prev_clicked)
    # next_button.on_click(on_next_clicked)

    # display_table(setting['current'])

    # display(widgets.HBox([prev_button, next_button, page_label]))
    # display(output)


def run_task_by_rid(rid: int):
    t = submit(get_task_by_rid(rid) | {'base': get_config_by_rid(rid)})
    t.bar()
    return t


def get_task_by_rid(rid: int):
    from ._db import get_dataset_by_tid

    return get_dataset_by_tid(get_tid_by_rid(rid), True)


def get_config_by_rid(rid: int):
    return get_config_by_tid(get_tid_by_rid(rid))


def get_config_by_tid(tid: int) -> dict:
    # git config --global --add safe.directory path/to/cfg
    from ._db import get_commit_by_tid
    try:
        commit, file = get_commit_by_tid(tid)

        return loads(commit.tree[file.name].data_stream.read().decode())
    except Exception as e:
        logger.error(f'Failed to get config for {tid}: {e}')
        return {}


def get_data_by_rid(rid: int, **kwds):
    return get_data_by_tid(get_tid_by_rid(rid), **kwds)


def get_data_by_tid(tid: int, **kwds) -> dict:
    # """load data with given **task id(tid)**

    # Args:
    #     tid (int): task id

    # Keyword Arguments: Kwds
    #     plot (bool, optional): plot the result in QuarkStudio after the data is loaded(1D or 2D).

    # Returns:
    #     dict: data & meta
    # """
    from ._db import get_dataset_by_tid
    from ._viewer import plot

    retry = 3
    while retry > 0:
        # Windows: OSError: [Errno 0] Unable to synchronously open file (unable to lock file, errno = 0, error message = 'No error', Win32 GetLastError() = 33)
        # MacOSX: BlockingIOError: [Errno 35] Unable to synchronously open file (unable to lock file, errno = 35, error message = 'Resource Temporarily unavailable')
        try:
            info, data = get_dataset_by_tid(tid)
            break
        except Exception as e:
            logger.error(str(e))
            time.sleep(1)
            retry -= 1

    if kwds.get('plot', False):
        signal = info['meta']['other']['signal'].split('|')[0]
        task = Task({'meta': info['meta']})
        task.meta = info['meta']
        task.data = {signal: data[signal]}
        task.index = len(data[signal]) + 1
        return plot(task, backend=kwds.get('backend', 'studio'))

    return {'data': data, 'meta': info['meta']}


def update_remote_wheel(wheel: str, index: str | Path, host: str = '127.0.0.1', sudo: bool = False):
    # """update the package on remote device

    # Args:
    #     wheel (str): package to be installed.
    #     index (str): location of required packages (downloaded from PyPI).
    #     host (str, optional): IP address of remote device. Defaults to '127.0.0.1'.
    #     sudo (bool, optional): used on Mac or Linux. Defaults to False.
    # """
    if not host:
        return None, 'host address is required!'

    links = {}
    for filename in Path(index).glob('*.whl'):
        with open(filename, 'rb') as f:
            print(f'{filename} added to links!')
            links[filename.parts[-1]] = f.read()
    rs = connect('QuarkRemote', host=host,
                 port=2087) if isinstance(host, str) else host
    sysinfo = rs.install(wheel, links, sudo)
    print(sysinfo)
    print(rs.restart())
    return rs, sysinfo


def translate(circuit: list = [(('Measure', 0), 'Q1001')], cfg: dict = {}, tid: int = 0, **kwds) -> tuple:
    # """translate circuit to executable commands(i.e., waveforms or settings)

    # Args:
    #     circuit (list, optional): qlisp circuit. Defaults to [(('Measure', 0), 'Q1001')].
    #     cfg (dict, optional): parameters of qubits in the circuit. Defaults to {}.
    #     tid (int, optional): task id used to load cfg. Defaults to 0.

    # Returns:
    #     tuple: context that contains cfg, translated result
    # """
    from quark.runtime import initialize, schedule

    ctx = initialize(cfg if cfg else get_config_by_tid(tid), main=True, **kwds)
    return ctx, schedule(0, {}, circuit, signal='iq', **kwds)


def preview(cmds: dict, keys: tuple[str] = ('',), calibrate: bool = True,
            start: float = 0, end: float = 0, srate: float = 0,
            unit: float = 1e-6, offset: float = 0, space: float = 0, ax=None):
    from copy import deepcopy

    import matplotlib.pyplot as plt
    from matplotlib.axes import Axes

    from quark.runtime import calculate

    ax: Axes = plt.subplot() if not ax else ax
    wf, index = deepcopy(cmds), 0
    for step, operations in wf.items():
        for target, cmd in operations.items():
            _target = cmd['cargs']['target']
            # if _target.split('.')[0] in keys:
            # value[-1]['filter'] = []

            calibration: dict = cmd['cargs'].get('calibration', {})
            for attr, value, default in [('srate', srate, 0), ('start', start, 0), ('end', end, 100e-6)]:
                if value:
                    calibration[attr] = value
                else:
                    calibration.setdefault(attr, default)

            if not calibrate:
                try:
                    calibration['delay'] = 0
                except Exception as e:
                    logger.error(f'{target, e}')

            # xt = np.arange(start, end, 1 / srate) / unit
            _, line = calculate(step, target, cmd, {'filter': keys})
            if target.endswith('Waveform') and _target.split('.')[0] in keys:
                xt = line[_target]['xdata'] / unit
                yt = line[_target]['ydata']
                wf[step][target]['value'] = yt
                offyt = yt + index * offset
                index += 1

                ax.plot(xt, offyt)
                ax.text(xt[-1], offyt[-1], _target, va='center')
                ax.set_xlim(xt[0] - space, xt[-1] + space)
    # plt.axis('off')
    # plt.legend(tuple(wf))
    return wf
